jest.mock('data/summit.json', () => ({
    time_zone_id: 'America/New_York'
}), { virtual: true });

import scheduleReducer from '../schedule-reducer';
import { getFilteredEvents } from '../../utils/schedule';
/**
 * We want to verify that your scheduleReducer properly handles the action:
 * { type: 'SCHED_CLEAR_FILTERS' }
 * That means:
 * - filters are reset to baseFilters
 * - baseFilters is not mutated
 * - A new list of events is generated by calling getFilteredEvents(...)
 */


/*
    mock getFilteredEvents
    we are not testing that function , we want to test if the reducer calls it correctly.
 */
jest.mock('../../utils/schedule', () => {
    const originalModule = jest.requireActual('../../utils/schedule');
    return {
        ...originalModule,
        preFilterEvents: jest.fn(() => ['event-1', 'event-2']),
        getFilteredEvents: jest.fn(() => ['filtered-event-1', 'filtered-event-2']),
        syncFilters: jest.fn((newF, _) => newF)
    };
});

describe('scheduleReducer - SCHED_CLEAR_FILTERS', () => {
    /*
     define a mock state for a schedule, simulating:
     - 2 filters (track, level) with current selections
     - baseFilters representing the "original empty state"
     - 2 allEvents, and 1 already filtered event
     */
    const initialState = {
        allEvents: ['event1', 'event2'],
        filters: {
            track: { label: 'Track', order: 1, values: ['Dev'], options: ['Dev', 'Ops'] },
            level: { label: 'Level', order: 2, values: ['Advanced'], options: ['Beginner', 'Advanced'] }
        },
        baseFilters: {
            track: { label: 'Track', order: 1, values: [], options: ['Dev', 'Ops'] },
            level: { label: 'Level', order: 2, values: [], options: ['Beginner', 'Advanced'] }
        },
        events: ['some-event'],
        hide_past_events_with_show_always_on_schedule: false
    };

    it('should reset filters to baseFilters with cleared values', () => {
        // dispatch action SCHED_CLEAR_FILTERS
        const action = { type: 'SCHED_CLEAR_FILTERS' };
        const newState = scheduleReducer(initialState, action);

        // filters match baseFilters
        expect(newState.filters).toEqual({
            track: { label: 'Track', order: 1, values: [], options: ['Dev', 'Ops'] },
            level: { label: 'Level', order: 2, values: [], options: ['Beginner', 'Advanced'] }
        });

        // getFilteredEvents was called with correct arguments
        expect(getFilteredEvents).toHaveBeenCalledWith(
            initialState.allEvents,
            newState.filters,
            expect.any(String), // summitTimeZoneId
            false
        );
        // events were updated from its return value
        expect(newState.events).toEqual(['filtered-event-1', 'filtered-event-2']);
    });

    it('should not mutate baseFilters object', () => {
        const baseClone = JSON.parse(JSON.stringify(initialState.baseFilters));
        scheduleReducer(initialState, { type: 'SCHED_CLEAR_FILTERS' });

        expect(initialState.baseFilters).toEqual(baseClone); // ensure not mutated
    });

});



describe('scheduleReducer - SCHED_UPDATE_FILTER', () => {
    const initialState = {
        allEvents: ['event1', 'event2'],
        filters: {
            track: { label: 'Track', order: 1, values: ['Dev'], options: ['Dev', 'Ops'] },
            level: { label: 'Level', order: 2, values: ['Advanced'], options: ['Beginner', 'Advanced'] }
        },
        baseFilters: {
            track: { label: 'Track', order: 1, values: [], options: ['Dev', 'Ops'] },
            level: { label: 'Level', order: 2, values: [], options: ['Beginner', 'Advanced'] }
        },
        events: [],
        hide_past_events_with_show_always_on_schedule: false
    };

    it('should update a single filter on SCHED_UPDATE_FILTER', () => {
        const action = {
            type: 'SCHED_UPDATE_FILTER',
            payload: {
                type: 'track',
                values: ['Ops'],
                hide_past_events_with_show_always_on_schedule: false
            }
        };

        const state = scheduleReducer(initialState, action);

        expect(state.filters.track.values).toEqual(['Ops']);
        expect(state.filters.level.values).toEqual(['Advanced']); // unchanged
        expect(getFilteredEvents).toHaveBeenCalled();
        expect(state.events).toEqual(['filtered-event-1', 'filtered-event-2']);
    });

    it('should replace filters and view on SCHED_UPDATE_FILTERS', () => {
        const action = {
            type: 'SCHED_UPDATE_FILTERS',
            payload: {
                view: 'list',
                filters: {
                    topic: { label: 'Topic', values: ['AI'], options: ['AI', 'ML'] }
                }
            }
        };

        const state = scheduleReducer(initialState, action);

        expect(state.view).toBe('list');
        expect(state.filters.topic.values).toEqual(['AI']);
        expect(state.events).toEqual(['filtered-event-1', 'filtered-event-2']);
    });

    it('should return the same state on unknown action', () => {
        const action = { type: 'UNKNOWN_ACTION' };
        const state = scheduleReducer(initialState, action);
        expect(state).toBe(initialState);
    });
});


describe('scheduleReducer - SCHED_RELOAD_SCHED_DATA', () => {
    // mock initial state
    const initialState = {
        filters: {},
        baseFilters: {},
        allEvents: [],
        events: [],
        timeFormat: '12h',
        hide_past_events_with_show_always_on_schedule: false
    };

    // mock action
    const action = {
        type: 'SCHED_RELOAD_SCHED_DATA',
        payload: {
            color_source: 'Track',
            pre_filters: { topic: { values: ['Dev'] } },
            all_events: ['raw-event-1', 'raw-event-2'],
            filters: {
                topic: {
                    label: 'Topic',
                    values: [],
                    options: ['Dev', 'Ops'],
                    order: 1
                }
            },
            baseFilters: {
                topic: {
                    label: 'Topic',
                    values: [],
                    options: ['Dev', 'Ops'],
                    order: 1
                }
            },
            only_events_with_attendee_access: true,
            hide_past_events_with_show_always_on_schedule: true,
            is_my_schedule: true,
            isLoggedUser: true,
            userProfile: { id: 123 },
            time_format: '24h'
        }
    };

    it('should reload schedule data and compute new filtered events', () => {

        // dispatch action
        const newState = scheduleReducer(initialState, action);

        expect(newState.allEvents).toEqual(['event-1', 'event-2']);
        expect(newState.colorSource).toBe('track');
        expect(newState.filters).toEqual(action.payload.filters);
        expect(newState.baseFilters).toEqual(action.payload.baseFilters);
        expect(newState.events).toEqual(['filtered-event-1', 'filtered-event-2']);
        // This confirms that state.timeFormat is preserved from the previous state if already defined,
        // even though 24h is in the payload.
        expect(newState.timeFormat).toBe('12h'); // keeps existing unless null
    });
});